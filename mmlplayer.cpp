#include <iostream>
#include <algorithm>
#include <cstring>
#include "mmlplayer.h"



void MMLPlayer::FMInst::Clear(void)
{
	instName="";
	DT_MULTI[0]=0;
	DT_MULTI[1]=0;
	DT_MULTI[2]=0;
	DT_MULTI[3]=0;
	TL[0]=0;
	TL[1]=0;
	TL[2]=0;
	TL[3]=0;
	KS_AR[0]=0;
	KS_AR[1]=0;
	KS_AR[2]=0;
	KS_AR[3]=0;
	AMON_DR[0]=0;
	AMON_DR[1]=0;
	AMON_DR[2]=0;
	AMON_DR[3]=0;
	SR[0]=0;
	SR[1]=0;
	SR[2]=0;
	SR[3]=0;
	SL_RR[0]=0;
	SL_RR[1]=0;
	SL_RR[2]=0;
	SL_RR[3]=0;
	FB_CNCT=0;
	LR_AMS_PMS=0;
}



////////////////////////////////////////////////////////////



void MMLPlayer::Channel::Clear(void)
{
	// Segment player expects tempo, octave, noteLength inherited from the previous segment.
	// Don't clear them.
	// tempo=TEMPO_DEFAULT;
	// octave=OCTAVE_DEFAULT;
	// noteLength=NOTE_LENGTH_DEFAULT;

	ptr.Clear();
	mml="";
}

bool MMLPlayer::Channel::PlayDone(void) const
{
	return mml.size()<=ptr.pos && INFINITE==ptr.toneEndAtInMicrosec;
}



////////////////////////////////////////////////////////////



void MMLPlayer::PlayPointer::Clear(void)
{
	pos=0;
	keyOffAtInMicrosec=INFINITE;
	toneEndAtInMicrosec=INFINITE;
}



////////////////////////////////////////////////////////////



void MMLPlayer::MMLError::Clear(void)
{
	chNum=0;
	errorCode=0;
	pos=0;
	MML="";
}

std::vector <std::string> MMLPlayer::MMLError::Format(void) const
{
	std::vector <std::string> errorMsg;

	errorMsg.push_back(ErrorCodeToStr(errorCode));
	errorMsg.push_back(MML);
	errorMsg.push_back("");
	for(int i=0; i<pos; ++i)
	{
		errorMsg.back().push_back(' ');
	}
	errorMsg.back().push_back('^');

	return errorMsg;
}


////////////////////////////////////////////////////////////



MMLPlayer::MMLPlayer()
{
	ym2612.state.volume=MMLPLAYER_VOLUME_DEFAULT;
	Clear();
}

void MMLPlayer::Clear(void)
{
	ClearMML();
	LoadFMB(defaultFMB);
	for(int chNum=0; chNum<NUM_CHANNELS; ++chNum)
	{
		mute[chNum]=false;
		ReapplyEnvelope(chNum);
	}
}

bool MMLPlayer::LoadFMB(const unsigned char fmb[6152])
{
	fmbName="";

	for(int i=0; i<8 && 0!=fmb[i]; ++i)
	{
		fmbName.push_back((char)fmb[i]);
	}

	fmb+=8;
	for(auto &ist : inst)
	{
		ist.Clear();
		for(int i=0; i<8 && 0!=fmb[i]; ++i)
		{
			ist.instName.push_back((char)fmb[i]);
		}

		ist.DT_MULTI[0]=fmb[8];
		ist.DT_MULTI[1]=fmb[9];
		ist.DT_MULTI[2]=fmb[10];
		ist.DT_MULTI[3]=fmb[11];
		ist.TL[0]      =fmb[12];
		ist.TL[1]      =fmb[13];
		ist.TL[2]      =fmb[14];
		ist.TL[3]      =fmb[15];
		ist.KS_AR[0]   =fmb[16];
		ist.KS_AR[1]   =fmb[17];
		ist.KS_AR[2]   =fmb[18];
		ist.KS_AR[3]   =fmb[19];
		ist.AMON_DR[0] =fmb[20];
		ist.AMON_DR[1] =fmb[21];
		ist.AMON_DR[2] =fmb[22];
		ist.AMON_DR[3] =fmb[23];
		ist.SR[0]      =fmb[24];
		ist.SR[1]      =fmb[25];
		ist.SR[2]      =fmb[26];
		ist.SR[3]      =fmb[27];
		ist.SL_RR[0]   =fmb[28];
		ist.SL_RR[1]   =fmb[29];
		ist.SL_RR[2]   =fmb[30];
		ist.SL_RR[3]   =fmb[31];
		ist.FB_CNCT    =fmb[32];
		ist.LR_AMS_PMS =fmb[33];

		fmb+=48;
	}
	return true;
}

void MMLPlayer::ClearMML(void)
{
	timeInMicrosec=0;
	for(auto &ch : channels)
	{
		ch.Clear();
	}
}

bool MMLPlayer::AddMML(unsigned int ch,std::string mml)
{
	if(ch<NUM_CHANNELS)
	{
		channels[ch].mml+=mml;
		return true;
	}
	return false;
}

std::vector <unsigned char> MMLPlayer::GenerateWave(uint64_t timeInMillisec)
{
	lastError.Clear();

	const uint64_t totalNumSamples=YM2612::WAVE_SAMPLING_RATE*timeInMillisec/MILLI;
	const uint64_t bufSize=4*totalNumSamples;
	std::vector <unsigned char> wave;

	wave.resize(bufSize);
	std::memset(wave.data(),0,bufSize);

	uint64_t wavePtr=0;
	while(wavePtr<bufSize)
	{
		// Play up to the next cue point.
		for(int chNum=0; chNum<NUM_CHANNELS; ++chNum)
		{
			auto &ch=channels[chNum];
			if(ch.ptr.keyOffAtInMicrosec<=timeInMicrosec)
			{
				if(chNum<3)
				{
					ym2612.WriteRegister(0,YM2612::REG_KEY_ON_OFF,chNum);
				}
				else
				{
					ym2612.WriteRegister(0,YM2612::REG_KEY_ON_OFF,(chNum+1));
				}
				ch.ptr.keyOffAtInMicrosec=INFINITE;
			}
			if(ch.ptr.toneEndAtInMicrosec<=timeInMicrosec || ch.ptr.toneEndAtInMicrosec==INFINITE)
			{
				ch.ptr.toneEndAtInMicrosec=INFINITE;
				if(true!=InterpretMML(chNum))
				{
					wave.clear();
					return wave;
				}
			}
		}


		// Break if no more channels are playing.
		// End of segment needs to be checked before generating a wave.
		// After the last MML interpretation, all channels next cue point is INFINITE away.
		// So is the nearest next cue point.
		// Which makes wave generator fill the buffer all the way, unless the loop breaks before the wave generation.
		unsigned int nPlaying=0;
		for(auto &ch : channels)
		{
			if(true!=ch.PlayDone())
			{
				++nPlaying;
				break;
			}
		}
		if(0==nPlaying)
		{
			break;
		}


		// Find next cue point.
		uint64_t nextCueInMicrosec=INFINITE;
		for(auto &ch : channels)
		{
			nextCueInMicrosec=std::min(nextCueInMicrosec,ch.ptr.keyOffAtInMicrosec);
			nextCueInMicrosec=std::min(nextCueInMicrosec,ch.ptr.toneEndAtInMicrosec);
		}

		// Generate wave up to the next cue point or the length of the wave.
		uint64_t dt=nextCueInMicrosec-timeInMicrosec;
		uint64_t numSamples=YM2612::WAVE_SAMPLING_RATE;
		numSamples*=dt;
		numSamples/=MICRO;
		if(0==numSamples)
		{
			numSamples=1;
		}

		numSamples=std::min(numSamples,totalNumSamples-(wavePtr/4));

		ym2612.MakeWaveForNSamples(wave.data()+wavePtr,numSamples);
		wavePtr+=numSamples*4;

		uint64_t actualDt=numSamples;
		actualDt*=MICRO;
		actualDt/=YM2612::WAVE_SAMPLING_RATE;
		timeInMicrosec+=actualDt;
	}

	wave.resize(wavePtr);

	return wave;
}

MMLPlayer::MMLError MMLPlayer::GetLastError(void) const
{
	return lastError;
}

bool MMLPlayer::InterpretMML(int chNum)
{
	auto &ch=channels[chNum];
	while(ch.ptr.pos<ch.mml.size() && INFINITE==ch.ptr.toneEndAtInMicrosec)
	{
		auto errorPos=ch.ptr.pos; // This will be recorded as error position if any.
		char cmd=ch.mml[ch.ptr.pos++];
		if('a'<=cmd && cmd<='z')
		{
			cmd=cmd+'A'-'a';
		}
		switch(cmd)
		{
		case ' ':
			// Ignore space
			break;
		case 'R':
			{
				int L=GetNumber(chNum);
				if(0==L)
				{
					L=ch.noteLength;
				}

				uint64_t noteDurationInMicrosec=60*MICRO*4;
				if('.'==ch.mml[ch.ptr.pos])
				{
					noteDurationInMicrosec*=3;
					noteDurationInMicrosec/=2;
					++ch.ptr.pos;
				}
				noteDurationInMicrosec/=(ch.tempo*L);

				ch.ptr.toneEndAtInMicrosec=timeInMicrosec+noteDurationInMicrosec;
			}
			break;
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'A':
		case 'B':
			{
				int sharpOrFlat=0;
				if('#'==ch.mml[ch.ptr.pos] || '+'==ch.mml[ch.ptr.pos])
				{
					sharpOrFlat=1;
					++ch.ptr.pos;
				}
				else if('-'==ch.mml[ch.ptr.pos])
				{
					sharpOrFlat=-1;
					++ch.ptr.pos;
				}

				int L=GetNumber(chNum);
				if(0==L)
				{
					L=ch.noteLength;
				}

				uint64_t noteDurationInMicrosec=60*MICRO*4;
				if('.'==ch.mml[ch.ptr.pos])
				{
					noteDurationInMicrosec*=3;
					noteDurationInMicrosec/=2;
					++ch.ptr.pos;
				}
				noteDurationInMicrosec/=(ch.tempo*L);

				unsigned int note;
				note=('C'<=cmd ? cmd-'C' : 5+cmd-'A');

				unsigned int blk,fnum;
				OctaveNoteToBlockFnum(blk,fnum,ch.octave,note,sharpOrFlat);

				unsigned char highByte,lowByte;
				highByte=(blk<<3)|(fnum>>8);
				lowByte=fnum&255;
				ym2612.WriteRegister((chNum<3 ? 0 : 3),YM2612::REG_FNUM2+chNum%3,highByte);
				ym2612.WriteRegister((chNum<3 ? 0 : 3),YM2612::REG_FNUM1+chNum%3,lowByte);
				if(true!=mute[chNum])
				{
					if(chNum<3)
					{
						ym2612.WriteRegister(0,YM2612::REG_KEY_ON_OFF,0xF0|chNum);
					}
					else
					{
						ym2612.WriteRegister(0,YM2612::REG_KEY_ON_OFF,0xF0|(chNum+1));
					}
				}

				ch.ptr.toneEndAtInMicrosec=timeInMicrosec+noteDurationInMicrosec;
				if('&'==ch.mml[ch.ptr.pos])
				{
					ch.ptr.keyOffAtInMicrosec=INFINITE;
					++ch.ptr.pos;
				}
				else
				{
					ch.ptr.keyOffAtInMicrosec=timeInMicrosec+noteDurationInMicrosec*ch.keyOnTimeFraction/KEYON_TIME_FRACTION_MAX;
				}
			}
			break;
		case 'V':
			{
				auto vol=GetNumber(chNum);
				if(vol<0 || VOLUME_MAX<vol)
				{
					lastError.errorCode=ERROR_VOLUME;
					lastError.pos=errorPos;
					lastError.chNum=chNum;
					lastError.MML=ch.mml;
					return false;
				}
				ch.volume=vol;
				ReapplyEnvelope(chNum);
			}
			break;
		case 'O':
			{
				auto oct=GetNumber(chNum);
				if(oct<0 || OCTAVE_MAX<oct)
				{
					lastError.errorCode=ERROR_OCTAVE;
					lastError.pos=errorPos;
					lastError.chNum=chNum;
					lastError.MML=ch.mml;
					return false;
				}
				ch.octave=oct;
			}
			break;
		case '>':
			if(ch.octave+1<=OCTAVE_MAX)
			{
				++ch.octave;
			}
			break;
		case '<':
			if(0<ch.octave)
			{
				--ch.octave;
			}
			break;
		case 'L':
			{
				auto len=GetNumber(chNum);
				if(len<=0 || NOTE_LENGTH_MAX<len)
				{
					lastError.errorCode=ERROR_NOTE_LENGTH;
					lastError.pos=errorPos;
					lastError.chNum=chNum;
					lastError.MML=ch.mml;
					return false;
				}
				ch.noteLength=len;
			}
			break;
		case 'S':
			GetNumber(chNum); // Ignore to allow F-BASIC V3.0 MML
			break;
		case 'M':
			GetNumber(chNum); // Ignore to allow F-BASIC V3.0 MML
			break;
		case 'T':
			{
				auto tempo=GetNumber(chNum);
				if(tempo<=0 || TEMPO_MAX<tempo)
				{
					lastError.errorCode=ERROR_TEMPO;
					lastError.pos=errorPos;
					lastError.chNum=chNum;
					lastError.MML=ch.mml;
					return false;
				}
				ch.tempo=tempo;
			}
			break;
		case 'Q':
			{
				auto fraction=GetNumber(chNum);
				if(fraction<0 || KEYON_TIME_FRACTION_MAX<fraction)
				{
					lastError.errorCode=ERROR_FRACTION;
					lastError.pos=errorPos;
					lastError.chNum=chNum;
					lastError.MML=ch.mml;
					return false;
				}
				ch.keyOnTimeFraction=fraction;
			}
			break;
		case '@':
			{
				auto instNum=GetNumber(chNum)-1;
				if(instNum<0 || INST_NUM_MAX<instNum)
				{
					lastError.errorCode=ERROR_INSTRUMENT_NUMBER;
					lastError.pos=errorPos;
					lastError.chNum=chNum;
					lastError.MML=ch.mml;
					return false;
				}
				ch.instNum=instNum;
				ReapplyEnvelope(chNum);
			}
			break;
		default:
			lastError.errorCode=ERROR_UNDEFINED_COMMAND;
			lastError.pos=errorPos;
			lastError.chNum=chNum;
			lastError.MML=ch.mml;
			return false;
		}
	}
	return true;
}

void MMLPlayer::OctaveNoteToBlockFnum(unsigned int &blk,unsigned int &fnum,int octave,int note,int sharpOrFlat) const
{
	static const int noteToFnum[]=
	{
		619,
		656,
		695,
		736,
		780,
		826,
		875,
		927,
		983,
		1041,
		1103,
		1169,

		// Values taken from F-BASIC 386.  Off-frequency?
		// 619, // "O4C"
		// 654, // "O4C#"
		// 693, // "O4D"
		// 734, // "O4D#"
		// 778, // "O4E"
		// 824, // "O4F"
		// 873, // "O4F#"
		// 925, // "O4G"
		// 980, // "O4G#"
		// 1038, // "O4A"
		// 1100, // "O4A#"
		// 1165, // "O4B"
	};

	// # #  # # #
	//c d ef g a b
	//0 1 23 4 5 6
	//0123456789ab
	if(note<=2)
	{
		note*=2;
	}
	else
	{
		note=note*2-1;
	}

	note+=sharpOrFlat;
	if(note<0)
	{
		note+=12;
		--octave;
	}
	if(12<=note)
	{
		note-=12;
		++octave;
	}

	if(8<=octave)
	{
		blk=7;
		fnum=noteToFnum[note]*2;
	}
	else
	{
		blk=octave;
		fnum=noteToFnum[note];
	}
}

int MMLPlayer::GetNumber(int chNum)
{
	auto &ch=channels[chNum];
	int num=0;
	while(ch.ptr.pos<ch.mml.size() && '0'<=ch.mml[ch.ptr.pos] && ch.mml[ch.ptr.pos]<='9')
	{
		num*=10;
		num+=(ch.mml[ch.ptr.pos++]-'0');
	}
	return num;
}

void MMLPlayer::ReapplyEnvelope(int chNum)
{
	auto &ch=channels[chNum];
	auto i=inst[ch.instNum];
	auto CONN=(i.FB_CNCT&7);

	int nCarrierSlots,carrierSlots[4];
	YM2612::GetCarrierSlotFromConnection(nCarrierSlots,carrierSlots,CONN);

	for(auto j=0; j<nCarrierSlots; ++j)
	{
		auto slotNum=carrierSlots[j];
		int TL=i.TL[slotNum];
		TL+=(15-ch.volume)*2;
		TL=std::min<int>(YM2612::TL_MAX,TL);
		i.TL[slotNum]=TL;
	}

	auto chBase=(chNum<3 ? 0 : 3);
	auto chLow=(chNum%3);
	ym2612.WriteRegister(chBase,YM2612::REG_DT_MULTI+0x00+chLow,i.DT_MULTI[0]);
	ym2612.WriteRegister(chBase,YM2612::REG_DT_MULTI+0x04+chLow,i.DT_MULTI[1]);
	ym2612.WriteRegister(chBase,YM2612::REG_DT_MULTI+0x08+chLow,i.DT_MULTI[2]);
	ym2612.WriteRegister(chBase,YM2612::REG_DT_MULTI+0x0C+chLow,i.DT_MULTI[3]);

	ym2612.WriteRegister(chBase,YM2612::REG_TL+0x00+chLow,i.TL[0]);
	ym2612.WriteRegister(chBase,YM2612::REG_TL+0x04+chLow,i.TL[1]);
	ym2612.WriteRegister(chBase,YM2612::REG_TL+0x08+chLow,i.TL[2]);
	ym2612.WriteRegister(chBase,YM2612::REG_TL+0x0C+chLow,i.TL[3]);

	ym2612.WriteRegister(chBase,YM2612::REG_KS_AR+0x00+chLow,i.KS_AR[0]);
	ym2612.WriteRegister(chBase,YM2612::REG_KS_AR+0x04+chLow,i.KS_AR[1]);
	ym2612.WriteRegister(chBase,YM2612::REG_KS_AR+0x08+chLow,i.KS_AR[2]);
	ym2612.WriteRegister(chBase,YM2612::REG_KS_AR+0x0C+chLow,i.KS_AR[3]);

	ym2612.WriteRegister(chBase,YM2612::REG_AM_DR+0x00+chLow,i.AMON_DR[0]);
	ym2612.WriteRegister(chBase,YM2612::REG_AM_DR+0x04+chLow,i.AMON_DR[1]);
	ym2612.WriteRegister(chBase,YM2612::REG_AM_DR+0x08+chLow,i.AMON_DR[2]);
	ym2612.WriteRegister(chBase,YM2612::REG_AM_DR+0x0C+chLow,i.AMON_DR[3]);

	ym2612.WriteRegister(chBase,YM2612::REG_SR+0x00+chLow,i.SR[0]);
	ym2612.WriteRegister(chBase,YM2612::REG_SR+0x04+chLow,i.SR[1]);
	ym2612.WriteRegister(chBase,YM2612::REG_SR+0x08+chLow,i.SR[2]);
	ym2612.WriteRegister(chBase,YM2612::REG_SR+0x0C+chLow,i.SR[3]);

	ym2612.WriteRegister(chBase,YM2612::REG_SL_RR+0x00+chLow,i.SL_RR[0]);
	ym2612.WriteRegister(chBase,YM2612::REG_SL_RR+0x04+chLow,i.SL_RR[1]);
	ym2612.WriteRegister(chBase,YM2612::REG_SL_RR+0x08+chLow,i.SL_RR[2]);
	ym2612.WriteRegister(chBase,YM2612::REG_SL_RR+0x0C+chLow,i.SL_RR[3]);

	ym2612.WriteRegister(chBase,YM2612::REG_SSG_EG+0x00+chLow,0);
	ym2612.WriteRegister(chBase,YM2612::REG_SSG_EG+0x04+chLow,0);
	ym2612.WriteRegister(chBase,YM2612::REG_SSG_EG+0x08+chLow,0);
	ym2612.WriteRegister(chBase,YM2612::REG_SSG_EG+0x0C+chLow,0);

	ym2612.WriteRegister(chBase,YM2612::REG_FB_CNCT+chLow,i.FB_CNCT);
	ym2612.WriteRegister(chBase,YM2612::REG_LR_AMS_PMS+chLow,i.LR_AMS_PMS);
}

bool MMLPlayer::PlayDone(void) const
{
	for(auto &ch : channels)
	{
		if(true!=ch.PlayDone())
		{
			return false;
		}
	}
	return true;
}

uint64_t MMLPlayer::GetTimeInMicrosec(void) const
{
	return timeInMicrosec;
}



/* static */ std::string MMLPlayer::ErrorCodeToStr(int errCode)
{
	switch(errCode)
	{
	case ERROR_NOERROR:
		return "ERROR_NOERROR";
	case ERROR_UNDEFINED_COMMAND:
		return "ERROR_UNDEFINED_COMMAND";
	case ERROR_INSTRUMENT_NUMBER:
		return "ERROR_INSTRUMENT_NUMBER";
	case ERROR_VOLUME:
		return "ERROR_VOLUME";
	case ERROR_OCTAVE:
		return "ERROR_OCTAVE";
	case ERROR_NOTE_LENGTH:
		return "ERROR_NOTE_LENGTH";
	case ERROR_TEMPO:
		return "ERROR_TEMPO";
	case ERROR_FRACTION:
		return "ERROR_FRACTION";
	default:
		break;
	}
	return "? Error";
}

int MMLPlayer::GetLastErrorCode(void) const
{
	return lastError.errorCode;
}

////////////////////////////////////////////////////////////



void MMLSegmentPlayer::AddSegment(
		std::string ch0,
		std::string ch1,
		std::string ch2,
		std::string ch3,
		std::string ch4,
		std::string ch5)
{
	Segment seg;
	mmlSegments.push_back(seg);
	mmlSegments.back().mml[0]=ch0;
	mmlSegments.back().mml[1]=ch1;
	mmlSegments.back().mml[2]=ch2;
	mmlSegments.back().mml[3]=ch3;
	mmlSegments.back().mml[4]=ch4;
	mmlSegments.back().mml[5]=ch5;
}

std::vector <unsigned char> MMLSegmentPlayer::GenerateWave(const uint64_t timeInMillisec)
{
	lastError.Clear();

	std::vector <unsigned char> rawWaveData;

	uint64_t timeInMicrosec=timeInMillisec*(MICRO/MILLI);

	int repeatCount=0;
	while(true!=this->PlayDone() && 0<timeInMicrosec)
	{
		if(true==MMLPlayer::PlayDone())
		{
			if(playingSegment<mmlSegments.size())
			{
				MMLPlayer::ClearMML();
				MMLPlayer::AddMML(0,mmlSegments[playingSegment].mml[0]);
				MMLPlayer::AddMML(1,mmlSegments[playingSegment].mml[1]);
				MMLPlayer::AddMML(2,mmlSegments[playingSegment].mml[2]);
				MMLPlayer::AddMML(3,mmlSegments[playingSegment].mml[3]);
				MMLPlayer::AddMML(4,mmlSegments[playingSegment].mml[4]);
				MMLPlayer::AddMML(5,mmlSegments[playingSegment].mml[5]);
				++playingSegment;
				if(true==repeat)
				{
					playingSegment=0;
					++repeatCount;
					if(mmlSegments.size()<=repeatCount)
					{
						// Prevent infinite loop.
						// If no data is generated by going through one loop of
						// the entire song, probably it should stop.
						return rawWaveData;
					}
				}
			}
		}

		auto rawWavePiece=MMLPlayer::GenerateWave(timeInMillisec);
		if(0!=lastError.errorCode)
		{
			return rawWaveData;
		}

		uint64_t rawWavePieceLengthInMicrosec=rawWavePiece.size()*MICRO/(YM2612::WAVE_SAMPLING_RATE*OUTPUT_CHANNELS*OUTPUT_BYTES_PER_SAMPLE);
		if(rawWavePieceLengthInMicrosec<timeInMicrosec)
		{
			timeInMicrosec-=rawWavePieceLengthInMicrosec;
		}
		else
		{
			timeInMicrosec=0;
		}

		if(0==rawWaveData.size())
		{
			rawWaveData.swap(rawWavePiece);
		}
		else
		{
			rawWaveData.insert(rawWaveData.end(),rawWavePiece.begin(),rawWavePiece.end());
		}
	}

	if(true==PlayDone())
	{
		uint64_t requiredLength=
		    timeInMillisec*(YM2612::WAVE_SAMPLING_RATE*OUTPUT_CHANNELS*OUTPUT_BYTES_PER_SAMPLE)/MILLI;
		while(rawWaveData.size()<requiredLength)
		{
			rawWaveData.push_back(0);
		}
	}

	return rawWaveData;
}

void MMLSegmentPlayer::Clear(void)
{
	repeat=false;
	playingSegment=0;
	mmlSegments.clear();
	MMLPlayer::Clear();
}

bool MMLSegmentPlayer::PlayDone(void) const
{
	return (true==MMLPlayer::PlayDone() && mmlSegments.size()<=playingSegment);
}

void MMLPlayer::MuteChannels(bool ch0Mute,bool ch1Mute,bool ch2Mute,bool ch3Mute,bool ch4Mute,bool ch5Mute)
{
	mute[0]=ch0Mute;
	mute[1]=ch1Mute;
	mute[2]=ch2Mute;
	mute[3]=ch3Mute;
	mute[4]=ch4Mute;
	mute[5]=ch5Mute;
}

int MMLSegmentPlayer::GetCurrentSegment(void) const
{
	return playingSegment;
}
#include "mmlplayer.h"

const unsigned long long MMLPlayer::sizeof_defaultFMB=6152;

const unsigned char MMLPlayer::defaultFMB[6152]=

{

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x45,0x2e,0x50,0x49,0x41,0x4e,0x4f,0x00,

	0x01,0x00,0x01,0x01,0x7f,0x10,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x04,

	0x00,0x00,0x00,0x00,0x0f,0x00,0x0f,0x66,

	0x04,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x50,0x49,0x41,0x4e,0x4f,0x00,0x00,0x00,

	0x01,0x01,0x0c,0x01,0x34,0x24,0x2c,0x00,

	0x9f,0x9f,0x9a,0x9f,0x00,0x00,0x16,0x10,

	0x00,0x00,0x0c,0x04,0x00,0x00,0x50,0x07,

	0x0a,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x54,0x52,0x55,0x4d,0x50,0x45,0x54,0x00,

	0x01,0x01,0x01,0x01,0x18,0x7f,0x7f,0x00,

	0x0f,0x15,0x1f,0x16,0x00,0x0d,0x00,0x04,

	0x02,0x03,0x00,0x09,0x00,0x2f,0x00,0x77,

	0x3a,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x54,0x52,0x55,0x4d,0x50,0x45,0x54,0x00,

	0x02,0x24,0x21,0x28,0x18,0x00,0x00,0x00,

	0x0e,0x10,0x10,0x10,0x04,0x12,0x12,0x12,

	0x00,0x00,0x00,0x00,0x50,0x0b,0x0d,0x0b,

	0x3d,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x48,0x41,0x52,0x50,0x53,0x49,0x43,0x48,

	0x03,0x01,0x08,0x01,0x20,0x38,0x10,0x00,

	0x9f,0x9f,0x9f,0x1f,0x00,0x00,0x00,0x0b,

	0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x68,

	0x3a,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x4f,0x52,0x47,0x41,0x4e,0x00,0x00,0x00,

	0x08,0x0b,0x0b,0x01,0x20,0x2c,0x34,0x00,

	0x10,0x1f,0x1f,0x0d,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,

	0x39,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x4f,0x42,0x4f,0x45,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x19,0x20,0x50,0x00,

	0x0d,0x1f,0x1e,0x11,0x05,0x00,0x00,0x00,

	0x0a,0x00,0x00,0x00,0x30,0x00,0x00,0x0a,

	0x3b,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x43,0x4c,0x41,0x52,0x49,0x4e,0x45,0x54,

	0x01,0x01,0x01,0x01,0x1c,0x2c,0x28,0x00,

	0x0d,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,

	0x22,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x57,0x4f,0x4f,0x44,0x57,0x49,0x4e,0x44,

	0x02,0x05,0x04,0x01,0x20,0x30,0x20,0x00,

	0x1f,0x13,0x12,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,

	0x03,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x47,0x55,0x49,0x54,0x41,0x52,0x00,0x00,

	0x04,0x04,0x20,0x01,0x20,0x7f,0x20,0x00,

	0x1f,0x1f,0x1f,0x1f,0x0d,0x06,0x0b,0x09,

	0x04,0x0c,0x07,0x0e,0x66,0x20,0x85,0x6d,

	0x3b,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x4b,0x4f,0x54,0x4f,0x00,0x00,0x00,0x00,

	0x02,0x03,0x02,0x01,0x14,0x30,0x14,0x00,

	0x1f,0x1f,0x1f,0x1f,0x0f,0x08,0x0a,0x12,

	0x1d,0x11,0x12,0x03,0x64,0x65,0x86,0x26,

	0x32,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x48,0x41,0x52,0x50,0x00,0x00,0x00,0x00,

	0x02,0x04,0x09,0x01,0x7f,0x28,0x2c,0x00,

	0x4f,0x1f,0x5f,0xdf,0x00,0x0a,0x09,0x0c,

	0x00,0x0a,0x0e,0x02,0x08,0x60,0x70,0x22,

	0x22,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x45,0x2e,0x42,0x41,0x53,0x45,0x00,0x00,

	0x01,0x00,0x00,0x01,0x20,0x28,0x08,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x02,0x0c,

	0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x37,

	0x32,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x44,0x52,0x55,0x4d,0x00,0x00,0x00,0x00,

	0x0f,0x01,0x01,0x01,0x10,0x0c,0x08,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x0f,

	0x00,0x00,0x00,0x14,0x00,0x00,0x00,0xff,

	0x38,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x44,0x52,0x55,0x4d,0x00,0x00,0x00,0x00,

	0x30,0x21,0x21,0x20,0x10,0x38,0x20,0x00,

	0x9f,0x9f,0x9f,0x9f,0x17,0x00,0x00,0x0f,

	0x0a,0x00,0x00,0x04,0x20,0x00,0x00,0x29,

	0x32,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x42,0x45,0x4c,0x4c,0x00,0x00,0x00,0x00,

	0x06,0x0c,0x01,0x01,0x1c,0x1c,0x00,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x08,0x0f,

	0x00,0x00,0x10,0x08,0x00,0x00,0xb7,0xb7,

	0x24,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x42,0x45,0x4c,0x4c,0x00,0x00,0x00,0x00,

	0x06,0x0c,0x01,0x01,0x1c,0x1c,0x00,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x08,0x0f,

	0x00,0x00,0x10,0x08,0x00,0x00,0xb4,0xb3,

	0x24,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x42,0x45,0x4c,0x4c,0x00,0x00,0x00,0x00,

	0x06,0x06,0x01,0x01,0x1c,0x1c,0x00,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x08,0x0f,

	0x00,0x00,0x10,0x08,0x00,0x00,0xb3,0x84,

	0x24,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x45,0x4c,0x45,0x43,0x54,0x52,0x49,0x43,

	0x04,0x01,0x01,0x01,0x30,0x0c,0x18,0x10,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x01,0x01,

	0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x06,

	0x02,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x45,0x4c,0x45,0x43,0x54,0x52,0x49,0x43,

	0x01,0x07,0x01,0x01,0x7f,0x2c,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x09,0x0f,0x00,0x0f,0x37,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x45,0x4c,0x45,0x43,0x54,0x52,0x49,0x43,

	0x01,0x03,0x02,0x0a,0x15,0x34,0x10,0x1c,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x32,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x4d,0x45,0x54,0x41,0x4c,0x49,0x43,0x00,

	0x07,0x01,0x01,0x01,0x14,0x7f,0x04,0x7f,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x0a,0x00,

	0x00,0x00,0x0e,0x00,0x00,0x0f,0x5f,0x0f,

	0x3c,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x4d,0x45,0x54,0x41,0x4c,0x49,0x43,0x00,

	0x06,0x06,0x01,0x01,0x1c,0x1c,0x00,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x0f,0x0f,

	0x00,0x00,0x10,0x10,0x00,0x00,0xb8,0x88,

	0x24,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x4d,0x45,0x54,0x41,0x4c,0x49,0x43,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x08,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x06,

	0x00,0x00,0x00,0x08,0x0f,0x00,0x0f,0x26,

	0x04,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x4d,0x45,0x54,0x41,0x4c,0x49,0x43,0x00,

	0x07,0x06,0x01,0x01,0x1c,0x7f,0x00,0x7f,

	0x9f,0x1f,0x9f,0x1f,0x00,0x00,0x0f,0x0f,

	0x00,0x00,0x10,0x10,0x00,0x00,0xb8,0x88,

	0x24,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x50,0x53,0x47,0x00,0x00,0x00,0x00,0x00,

	0x02,0x0b,0x01,0x01,0x18,0x58,0x00,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0d,0x0e,0x0c,0x0e,

	0x3c,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x46,0x4e,0x59,0x4f,0x4e,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x4c,0x04,0x4c,0x00,

	0x1f,0x0c,0x1f,0x0f,0x00,0x0a,0x00,0x09,

	0x00,0x16,0x00,0x0e,0x00,0xf9,0x00,0xab,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x4e,0x4f,0x49,0x53,0x45,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x00,0x7f,0x00,0x7f,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x3c,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x01,0x01,0x01,0x01,0x7f,0x7f,0x7f,0x00,

	0x1f,0x1f,0x1f,0x1f,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,

	0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00



};

/* LICENSE>>

Copyright 2020 Soji Yamakawa (CaptainYS, http://www.ysflight.com)



Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:



1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.



2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.



3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.



THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



<< LICENSE */

#include <math.h>

#include <iostream>



#include "ym2612.h"







void YM2612::Slot::Clear(void)

{

	DT=0;

	MULTI=0;

	TL=0;

	KS=0;

	AR=0;

	AM=0;

	DR=0;

	SR=0;

	SL=0;

	RR=0;

	SSG_EG=0;

}

void YM2612::Channel::Clear()

{

	F_NUM=0;

	BLOCK=0;

	FB=0;

	CONNECT=0;

	L=1;

	R=1;

	AMS=0;

	PMS=0;

	usingSlot=0;

	for(auto &s : slots)

	{

		s.Clear();

	}

}



////////////////////////////////////////////////////////////



/*static*/ int YM2612::sineTable[YM2612::PHASE_STEPS];

/*static*/ unsigned int YM2612::TLtoDB100[128];   // 100 times dB

/*static*/ unsigned int YM2612::SLtoDB100[16];    // 100 times dB

/*static*/ unsigned int YM2612::DB100to4095Scale[9601]; // dB to 0 to 4095 scale

/*static*/ unsigned int YM2612::DB100from4095Scale[4096]; // 0 to 4095 scale to dB

/*static*/ unsigned int YM2612::linear4096to9600[4097]; // Linear 4096 scale to 9600 scale

/*static*/ unsigned int YM2612::linear9600to4096[9601]; // Linear 9600 scale to 4096 scale

/*static*/ const unsigned int YM2612::connToOutChannel[8][4]=

{

	{0,0,0,1},

	{0,0,0,1},

	{0,0,0,1},

	{0,0,0,1},

	{0,1,0,1},

	{0,1,1,1},

	{0,1,1,1},

	{1,1,1,1},

};



void YM2612::State::PowerOn(void)

{

	Reset();

}

void YM2612::State::Reset(void)

{

	deviceTimeInNS=0;

	lastTickTimeInNS=0;

	for(auto &c : channels)

	{

		c.Clear();

	}

	for(auto &f : F_NUM_3CH)

	{

		f=0;

	}

	for(auto &b : BLOCK_3CH)

	{

		b=0;

	}

	for(auto &f : F_NUM_6CH)

	{

		f=0;

	}

	for(auto &b : BLOCK_6CH)

	{

		b=0;

	}

	for(auto &r : reg)

	{

		r=0;

	}

	for(auto &t : timerCounter)

	{

		t=0;

	}

	for(auto &b : timerUp)

	{

		b=false;

	}

	for(auto &ch : channels)

	{

		for(auto &slot : ch.slots)

		{

			slot.lastDbX100Cache=0;

		}

	}

	playingCh=0;

	LFO=0;

	FREQCTRL=0;

}



////////////////////////////////////////////////////////////



YM2612::YM2612()

{

	std::cout << "YM2612 Emulator for Tsugaru [Tsugaru-Ben]" << std::endl;



	MakeSineTable();

	MakeTLtoDB100();

	MakeSLtoDB100();

	MakeDB100to4095Scale();

	MakeLinearScaleTable();

	MakeAttackProfileTable();

	PowerOn();

}

YM2612::~YM2612()

{

}



void YM2612::MakeSineTable(void)

{

	const double PI=3.14159265358979323;

	for(int i=0; i<PHASE_STEPS; ++i)

	{

		double a=2.0*PI*(double)i/(double)PHASE_STEPS;

		double s=sin(a);

		s*=(double)(UNSCALED_MAX);

		sineTable[i]=(int)s;

		// printf("%+-6d,",(int)s);

		// if(i%16==15)

		// {

		// 	printf("\n");

		// }

	}

}

void YM2612::MakeTLtoDB100(void)

{

	for(unsigned int TL=0; TL<128; ++TL)

	{

		TLtoDB100[TL]=TL*75;

	}

}

void YM2612::MakeSLtoDB100(void)

{

	for(unsigned int SL=0; SL<16; ++SL)

	{

		SLtoDB100[SL]=SL*300;

	}

}

void YM2612::MakeDB100to4095Scale(void)

{

	// To convert 0 to 96dB (log scale) to amplitude 0 to 4095,

	//    dB=20*log10(C*amplitude)

	//    96=20*log10(C*4095)

	//    4.8=log10(C*4095)

	//    10^4.8=C*4095

	//    C=(10^4.8)/4095.0

	const double C=pow(10.0,4.8)/4095.0;



	//    dB=20*log10(C*amplitude)

	//    log10(C*amplitude)=dB/20

	//    10^(dB/20)=C*amplitude

	//    amplitude=(10^(dB/20))/C



	for(int i=0; i<=9600; ++i)

	{

		double dB=(double)i/100.0;

		DB100to4095Scale[i]=(unsigned int)(pow(10.0,dB/20.0)/C);

		// if(0==i%100)

		// {

		// 	printf("%4ddB -> %4d\n",i/100,DB100to4095Scale[i]);

		// }

	}

	for(int i=0; i<4096; ++i)

	{

		double dB100=100.0*(20.0*log10(C*(double)i));

		DB100from4095Scale[i]=(unsigned int)dB100;

	}

}

void YM2612::MakeLinearScaleTable(void)

{

	for(unsigned int i=0; i<=4096; ++i)

	{

		linear4096to9600[i]=i*9600/4096;

	}

	for(unsigned int i=0; i<=9600; ++i)

	{

		linear9600to4096[i]=i*4096/9600;

	}

}



void YM2612::MakeAttackProfileTable(void)

{

	// YM2612 manual tells that the output level increases during the attack phase is exponential,

	// which can open up a lot of interpretations.  Is it like dB(t)=C*k^t  ?

	// By looking at fmgen by Cisc, it seems to be the difference from the peak output decreases

	// exponentially.

	//

	// If the level difference from the maximum level is diff(i),

	//     diff(i+1)=diff(i)*k   {0<t<1}

	// Then,

	//     diff(i)=diff(0)*(k^i) {0<t<1}

	// Let's say the maximum is 4096.  I want to say diff reaches 0 at t=4096, but well it won't be zero.

	// So, let's say diff reaches 1 at t=409t instead.  The initial difference is 4096.  Then,

	// 

	//     1=4096*t^4095, 

	// 

	// From there, I can calculate t.  And then values for the table.



	const double lastErr=0.014;

	const double t=pow(lastErr,1.0/4096.0);

	for(int i=0; i<4096; ++i)

	{

		double y=(1.0-pow(t,(double)i))/(1.0-lastErr);

		attackExp[i]=(int)(y*4096);

	}



	int j=0;

	for(int i=0; i<4096; ++i)

	{

		for(; j<=attackExp[i+1]; ++j)

		{

			attackExpInverse[j]=i;

		}

	}

}



void YM2612::PowerOn(void)

{

	state.PowerOn();

}

void YM2612::Reset(void)

{

	state.Reset();

}

unsigned int YM2612::WriteRegister(unsigned int channelBase,unsigned int reg,unsigned int value)

{

	if(true==takeRegLog)

	{

		RegWriteLog rwl;

		rwl.chBase=(unsigned char)channelBase;

		rwl.reg=(unsigned char)reg;

		rwl.data=(unsigned char)value;

		rwl.count=1;

		if(0<regWriteLog.size() &&

		   regWriteLog.back().chBase==rwl.chBase &&

		   regWriteLog.back().reg==rwl.reg &&

		   regWriteLog.back().data==rwl.data)

		{

			++regWriteLog.back().count;

		}

		else

		{

			regWriteLog.push_back(rwl);

		}

	}

	unsigned int chStartPlaying=65535;

	static const unsigned int slotTwist[4]={0,2,1,3};

	reg&=255;

	auto prev=state.reg[reg];

	state.reg[reg]=value;

	if(REG_TIMER_CONTROL==reg)

	{

		// [2] pp. 202 RESET bits will be cleared immediately after set.

		// .... I interpret it as RESET bits are always read to zero.

		state.reg[REG_TIMER_CONTROL]&=0xCF;



		// LOAD bits are mysterious.

		// [2] pp.201 tells that writing 1 to LOAD bit resets the counter and start counting.

		// Towns OS's behavior does not seem to be agree with it.

		// Timer A interrupt handler writes 0x3F to register 0x27.  If I implement as [2] pp.201,

		// Timer B counter is reset when Timer A is up, or vise versa.

		// Slower one of Timer A or B will never be up.

		//

		// There are some possibilities:

		// (1) The timer counter resets on the rising edge of LOAD.  When timer is up, LOAD will be cleared.

		//     Therefore, writing LOAD=1 when LOAD is already 1 does nothing.

		// (2) Towns OS writes (0118:[0727H])|0x15 for Timer A or (0118:[0727H])|0x2A for Timer B for resetting the counter.

		//     0118:[0727H] is a cached value (or read back) from YM2612 register 27H.  If LOAD bits are always zero when

		//     read, it won't reset the timer when resetting the other timer.

		// (3) The timer counter is reloaded on LOAD=1 only if the timer is up.

        //

		// There are some web sites such as:

		//   https://plutiedev.com/ym2612-registers#reg-27

		//   https://www.smspower.org/maxim/Documents/YM2612

		//   https://wiki.megadrive.org/index.php?title=YM2612_Registers

		// suggesting that LOAD bit means the timer is running.  If so, I guess (2) is unlikely.

		// With my elementary knowledge in FPGA programming, (1) looks to be more straight-forward.

		// Currently I go with (1).



		if(0==(prev&1) && 0!=(value&1)) // Load Timer A

		{

			unsigned int countHigh=state.reg[REG_TIMER_A_COUNT_HIGH];

			unsigned int countLow=state.reg[REG_TIMER_A_COUNT_LOW];

			auto count=(countHigh<<2)|(countLow&3);

			state.timerCounter[0]=count*TIMER_A_PER_TICK;

		}

		if(0==(prev&2) && 0!=(value&2)) // Load Timer B

		{

			state.timerCounter[1]=(unsigned int)(state.reg[REG_TIMER_B_COUNT])*TIMER_B_PER_TICK;

		}

		if(value&4) // Enable Timer A Flag

		{

		}

		if(value&8) // Enable Timer B Flag

		{

		}

		if(value&0x10) // Reset Timer A Flag

		{

			state.timerUp[0]=false;

		}

		if(value&0x20) // Reset Timer B Flag

		{

			state.timerUp[1]=false;

		}

	}

	else if(REG_KEY_ON_OFF==reg)

	{

		static unsigned int chTwist[8]={0,1,2,255,3,4,5,255};

		unsigned int ch=chTwist[value&7];

		if(ch<6)

		{

			unsigned int slotFlag=((value>>4)&0x0F);



			unsigned int onSlots=(~state.channels[ch].usingSlot)&slotFlag;

			unsigned int offSlots=(state.channels[ch].usingSlot&(~slotFlag))&0x0F;



			// Prob, this is the trigger to start playing.

			// F-BASIC386 first writes SLOT=0 then SLOT=0x0F.

			if(0!=onSlots)

			{

				// Play a tone

				KeyOn(ch,onSlots);

				chStartPlaying=ch;

			}

			if(0!=offSlots)

			{

				KeyOff(ch,offSlots);

			}



			state.channels[ch].usingSlot=slotFlag;

		}

	}

	else if(REG_LFO==reg)

	{

		state.LFO=(0!=(value&8));

		state.FREQCTRL=value&7;

	}

	else if(0xA8<=reg && reg<=0xAE) // Special 3CH F-Number/BLOCK

	{

		unsigned int slot=(reg&3);

		if(slot<3)

		{

			if(0==channelBase)

			{

				if(reg<0xAC)

				{

					state.F_NUM_3CH[slot]&=0xFF00;

					state.F_NUM_3CH[slot]|=value;

				}

				else

				{

					state.F_NUM_3CH[slot]&=0xFF;

					state.F_NUM_3CH[slot]|=((value&7)<<8);

					state.BLOCK_3CH[slot]=((value>>3)&7);

				}

			}

			else if(3==channelBase)

			{

				if(reg<0xAC)

				{

					state.F_NUM_6CH[slot]&=0xFF00;

					state.F_NUM_6CH[slot]|=value;

				}

				else

				{

					state.F_NUM_6CH[slot]&=0xFF;

					state.F_NUM_6CH[slot]|=((value&7)<<8);

					state.BLOCK_6CH[slot]=((value>>3)&7);

				}

			}

		}

	}

	else if(0x30<=reg && reg<=0x9E) // Per Channel per slot

	{

		unsigned int ch=(reg&3);

		if(ch<=2)

		{

			const unsigned int slot=slotTwist[((reg>>2)&3)];

			ch+=channelBase;

			switch(reg&0xF0)

			{

			case 0x30: // DT, MULTI

				state.channels[ch].slots[slot].DT=((value>>4)&7);

				state.channels[ch].slots[slot].MULTI=(value&15);

				break;

			case 0x40: // TL

				{

					auto prevTL=state.channels[ch].slots[slot].TL;

					state.channels[ch].slots[slot].TL=(value&0x7F);

					if(0!=(state.channels[ch].usingSlot&(1<<slot)))

					{

						auto prevLevel=127-prevTL;

						auto newLevel=127-state.channels[ch].slots[slot].TL;

						UpdateSlotEnvelope(state.channels[ch],state.channels[ch].slots[slot]);

						if(0!=prevLevel)

						{

							// Must be linear in dB scale.  To prepare for subsequent release phase.

							state.channels[ch].slots[slot].lastDbX100Cache*=newLevel;

							state.channels[ch].slots[slot].lastDbX100Cache/=prevLevel;

						}

					}

					else if(true==state.channels[ch].slots[slot].InReleasePhase)

					{

						auto prevLevel=127-prevTL;

						auto newLevel=127-state.channels[ch].slots[slot].TL;

						if(0!=prevLevel)

						{

							// Must be linear in dB scale.  lastDbX100Cache shouldn't matter already.

							state.channels[ch].slots[slot].ReleaseStartDbX100*=newLevel;

							state.channels[ch].slots[slot].ReleaseStartDbX100/=prevLevel;

						}

					}

				}

				break;

			case 0x50: // KS,AR

				state.channels[ch].slots[slot].KS=((value>>6)&3);

				state.channels[ch].slots[slot].AR=(value&0x1F);

				break;

			case 0x60: // AM,DR

				state.channels[ch].slots[slot].AM=((value>>7)&1);

				state.channels[ch].slots[slot].DR=(value&0x1F);

				break;

			case 0x70: // SR

				state.channels[ch].slots[slot].SR=(value&0x1F);

				break;

			case 0x80: // SL,RR

				state.channels[ch].slots[slot].SL=((value>>4)&0x0F);

				state.channels[ch].slots[slot].RR=(value&0x0F);

				if(0!=(state.channels[ch].usingSlot&(1<<slot)))

				{

					UpdateSlotEnvelope(state.channels[ch],state.channels[ch].slots[slot]);

				}

				else if(true==state.channels[ch].slots[slot].InReleasePhase)

				{

					UpdateRelease(state.channels[ch],state.channels[ch].slots[slot]);

				}

				break;

			case 0x90: // SSG-EG

				state.channels[ch].slots[slot].SSG_EG=(value&0x0F);

				break;

			}

		}

	}

	else if(0xA0<=reg && reg<=0xB6)

	{

		unsigned int ch=(reg&3);

		if(ch<=2)

		{

			unsigned int slot=slotTwist[((reg>>2)&3)];

			ch+=channelBase;

			switch(reg&0xFC)

			{

			case 0xA0: // F-Number1

				// [2] pp.211 Implies that writing to reg A0H to A2H triggers a tone to play.

				//     When setting the note, first write BLOCK and high 3-bits of F-Number (F-Number2),

				//     and then write lower 8-bits of F-Number (F-Number1).

				//     Or, is it REG_KEY_ON_OFF?

				state.channels[ch].F_NUM&=0xFF00;

				state.channels[ch].F_NUM|=value;

				UpdatePhase12StepSlot(state.channels[ch]);

				break;

			case 0xA4: // BLOCK,F-Number2

				state.channels[ch].F_NUM&=0x00FF;

				state.channels[ch].F_NUM|=((value&7)<<8);

				state.channels[ch].BLOCK=((value>>3)&7);

				break;

			case 0xB0: // FB, CONNECT

				state.channels[ch].FB=((value>>3)&7);

				state.channels[ch].CONNECT=(value&7);

				break;

			case 0xB4: // L,R,AMS,PMS

				state.channels[ch].L=((value>>7)&1);

				state.channels[ch].R=((value>>6)&1);

				state.channels[ch].AMS=((value>>4)&3);

				state.channels[ch].PMS=(value&7);

				break;

			}

		}

	}

	return chStartPlaying;

}

unsigned int YM2612::ReadRegister(unsigned int channelBase,unsigned int reg) const

{

	return state.reg[reg&255];

}

void YM2612::Run(unsigned long long int systemTimeInNS)

{

	if(0==state.deviceTimeInNS)

	{

		state.lastTickTimeInNS=systemTimeInNS;

		state.deviceTimeInNS=systemTimeInNS;

		return;

	}

	if(state.lastTickTimeInNS+TICK_DURATION_IN_NS<systemTimeInNS)

	{

		auto nTick=(systemTimeInNS-state.lastTickTimeInNS)/TICK_DURATION_IN_NS;

		state.lastTickTimeInNS+=nTick*TICK_DURATION_IN_NS;

		// See (1) in the above comment.

		if(0!=(state.reg[REG_TIMER_CONTROL]&0x01))

		{

			state.timerCounter[0]+=nTick;

			if(NTICK_TIMER_A<=state.timerCounter[0])

			{

				state.reg[REG_TIMER_CONTROL]&=(~0x01);

				if(0!=(state.reg[REG_TIMER_CONTROL]&0x04))

				{

					state.timerUp[0]=true;

				}

			}

		}

		if(0!=(state.reg[REG_TIMER_CONTROL]&0x02))

		{

			state.timerCounter[1]+=nTick;

			if(NTICK_TIMER_B<=state.timerCounter[1])

			{

				state.reg[REG_TIMER_CONTROL]&=(~0x02);

				if(0!=(state.reg[REG_TIMER_CONTROL]&0x08))

				{

					state.timerUp[1]=true;

				}

			}

		}

	}





	state.deviceTimeInNS=systemTimeInNS;

}

bool YM2612::TimerAUp(void) const

{

	return state.timerUp[0];

}

bool YM2612::TimerBUp(void) const

{

	return state.timerUp[1];

}

bool YM2612::TimerUp(unsigned int timerId) const

{

	switch(timerId&1)

	{

	default:

	case 0:

		return TimerAUp();

	case 1:

		return TimerBUp();

	}

}



/* static */ void YM2612::GetCarrierSlotFromConnection(int &numCarrierSlots,int carrierSlots[4],unsigned int connection)

{

	connection&=7;

	numCarrierSlots=connectionToOutputSlots[connection].nOutputSlots;

	carrierSlots[0]=connectionToOutputSlots[connection].slots[0];

	carrierSlots[1]=connectionToOutputSlots[connection].slots[1];

	carrierSlots[2]=connectionToOutputSlots[connection].slots[2];

	carrierSlots[3]=connectionToOutputSlots[connection].slots[3];

}







std::vector <std::string> YM2612::GetStatusText(void) const

{

	std::vector <std::string> text;

	char str[256];



	text.push_back("YM2612");



	for(int chNum=0; chNum<6; ++chNum)

	{

		auto &ch=state.channels[chNum];



		sprintf(str,"CH:%d  F_NUM=%-5d  BLOCK=%-2d  FB=%d  CONNECT=%d  L=%d  R=%d  AMS=%d  PMS=%d  ActiveSlots=%02x",

			chNum,

			ch.F_NUM,

			ch.BLOCK,

			ch.FB,

			ch.CONNECT,

			ch.L,

			ch.R,

			ch.AMS,

			ch.PMS,

			ch.usingSlot);

		text.push_back(str);



		int s=0;

		for(auto &slot : ch.slots)

		{

			sprintf(str,"SLOT:%d  DT=%d  MULTI=%-2d  TL=%-3d(%2ddB)  KS=%d  AR=%-2d  AM=%d  DR=%-2d  SR=%-2d  SL=%2d(%2ddB)  RR=%-2d  SSG_EG=%d",

				s,

				slot.DT,

				slot.MULTI,

				slot.TL,

				TLtoDB100[slot.TL]/100,

				slot.KS,

				slot.AR,

				slot.AM,

				slot.DR,

				slot.SR,

				slot.SL,

				SLtoDB100[slot.SL]/100,

				slot.RR,

				slot.SSG_EG);

			text.push_back(str);

			++s;

		}

	}





	sprintf(str,"TimerA Up=%d  Count Preset=0x%04x  Internal Count/Threshold=0x%08x/0x%08x",

		TimerAUp(),

		((state.reg[REG_TIMER_A_COUNT_HIGH]<<2)|(state.reg[REG_TIMER_A_COUNT_LOW]&3)),

		(state.timerCounter[0]&0xFFFFFFFF),

		NTICK_TIMER_A);

	text.push_back(str);





	sprintf(str,"TimerB Up=%d  Count Preset=0x%04x  Internal Count/Threshold=0x%08x/0x%08x",

		TimerBUp(),

		state.reg[REG_TIMER_B_COUNT],

		(state.timerCounter[1]&0xFFFFFFFF),

		NTICK_TIMER_B);

	text.push_back(str);





	sprintf(str,"Timer Control(Reg 0x%02x)=0x%02x  MODE:0x%02x  RST:0x%02x  ENA:0x%02x  LOAD:0x%02x",

		REG_TIMER_CONTROL,

		state.reg[REG_TIMER_CONTROL],

		((state.reg[REG_TIMER_CONTROL]>>6)&3),

		((state.reg[REG_TIMER_CONTROL]>>4)&3),

		((state.reg[REG_TIMER_CONTROL]>>2)&3),

		(state.reg[REG_TIMER_CONTROL]&3));

	text.push_back(str);





	sprintf(str,"LFO:%d  FREQ-CTRL:%d",state.LFO,state.FREQCTRL);

	text.push_back(str);



	return text;

}

/* LICENSE>>

Copyright 2020 Soji Yamakawa (CaptainYS, http://www.ysflight.com)



Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:



1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.



2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.



3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.



THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



<< LICENSE */

#include <algorithm>

#include <iostream>

#include <cstring>



#include "ym2612.h"







inline void WordOp_Set(unsigned char *ptr,short value)

{

#ifdef YS_LITTLE_ENDIAN

	if(value<-32767)

	{

		*((short *)ptr)=-32767;

	}

	else if(32767<value)

	{

		*((short *)ptr)=32767;

	}

	else

	{

		*((short *)ptr)=value;

	}

#else

	if(value<-32767)

	{

		value=-32767;

	}

	else if(32767<value)

	{

		value=32767;

	}

	ptr[0]=value&255;

	ptr[1]=(value>>8)&255;

#endif

}







// #define YM2612_DEBUGOUTPUT





/*static*/ int YM2612::MULTITable[16]= // Multiple x2.

{

	1,

	2,

	4,

	6,

	8,

	10,

	12,

	14,

	16,

	18,

	20,

	22,

	24,

	26,

	28,

	30,

};



// Attack/Decay/Sustain/Release rate becomes double every four steps in 64-level scale.

// However between i*4 and (i+1)*4, the slope is linearly interpolated.

// Therefore, the slope should be:

//    i=N*4    a

//    i=N*4+1  a*1.25

//    i=N*4+2  a*1.5

//    i=N*4+3  a*1.75

//    i=N*4+4  a*2

//     :

//    i=N*4+8  a*4

//

// The duration of the segment is inverse of the slope, therefore:

//    i=N*4    d

//    i=N*4+1  d/1.25

//    i=N*4+2  d/1.5

//    i=N*4+3  d/1.75

//    i=N*4+4  d/2

//     :

//    i=N*4+8  d/4

//

// The duration of decay/sustain/release depends on how much dB the segment needs to drop.

// It is linear to the dB-drop.

//

// The duration of attack (based on the observation) is constant regardless of the total level.

//

// The observation indicated that the values listed in FM TOWNS Technical Databook was

// about 10% slower than actual.



static unsigned int attackTime0to96dB[64]= // 1/100ms

{

// Note: The time must be proportional to the base clock.

// Measured/Estimated    FM TOWNS Technical Databook Table I-5-31

1606000,                 // Infinity,

1284800,                 // Infinity,

1070666,                 // Infinity,

917714,                  // Infinity,

803000,                  // 897024,

642400,                  // 897024,

535333,                  // 598016,

458857,                  // 598016,

401500,                  // 448512,

321200,                  // 358810,

267666,                  // 299008,   // Actual Measurement 2677ms

229428,                  // 258293,

200750,                  // 224256,

160600,                  // 173405,

133833,                  // 149504,

114714,                  // 128146,



100375,                  // 112128,

80300,                   // 83702,

66916,                   // 74752,

57357,                   // 64073,

50187,                   // 56064,

40149,                   // 44851,

33458,                   // 37376,

28678,                   // 32037,

25093,                   // 28032,

20074,                   // 22425,

16728,                   // 18688,

14338,                   // 16018,

12546,                   // 14016,

10036,                   // 11213,

8364,                    // 9344,

7169,                    // 8009,



6273,                    // 7008,

5018,                    // 5806,

4182,                    // 4872,

3584,                    // 4005,

3136,                    // 3504,

2508,                    // 2903,

2090,                    // 2335,

1792,                    // 2002,

1568,                    // 1752,

1254,                    // 1402,

1045,                    // 1168,

896,                     // 1001,

784,                     // 876,

627,                     // 701,

522,                     // 584,

448,                     // 501,



392,                     // 438,

313,                     // 350,

261,                     // 232,

224,                     // 250,

196,                     // 240,

156,                     // 192,

130,                     // 160,

112,                     // 137,

98,                      // 126,

78,                      // 101,

65,                      // 84,

56,                      // 72,

49,                      // 60,

39,                      // 60,

32,                      // 0,

28,                      // 0,

};

static unsigned int sustainDecayReleaseTime0to96dB[64]= // 1/100ms

{

// Measured/Estimated    FM TOWNS Technical Databook Table I-5-31

22662400,               // Infinity

18129920,               // Infinity

15108266,               // Infinity

12949942,               // Infinity

11331200,               // 12398592,

9064960,                // 12398592,

7554133,                // 8265726,

6474971,                // 8265728,

5665600,                // 5199296,   // Actual measurement: 56656ms (5665600)

4532480,                // 4953437,

3777066,                // 4132864,

3237485,                // 3542455,

2832800,                // 3099648,

2266240,                // 2479719,

1888533,                // 2066432,

1618742,                // 1771227,



1416400,                // 1549824,

1133120,                // 1239859,

944266,                 // 1033215,

809371,                 // 885614,

708200,                 // 774912,

566560,                 // 619930,

472133,                 // 516608,

404685,                 // 442807,

354100,                 // 387455,

283280,                 // 309965,

236066,                 // 258304,

202342,                 // 221403,

177050,                 // 193728,

141640,                 // 154982,

118033,                 // 129152,

101171,                 // 110702,



88525,                  // 96864,

70820,                  // 77491,

59016,                  // 64576,

50585,                  // 55351,

44262,                  // 48432,

35409,                  // 38745,

29508,                  // 32298,

25292,                  // 27675,

22131,                  // 24216,

17704,                  // 19373,

14754,                  // 16144,

12646,                  // 13938,

11065,                  // 12108,

8852,                   // 9686,

7376,                   // 8072,

6322,                   // 6919,



5532,                   // 6054,

4425,                   // 4843,

3688,                   // 4056,

3161,                   // 3459,

2766,                   // 3027,

2212,                   // 2422,

1844,                   // 2018,

1580,                   // 1730,

1383,                   // 1514,

1106,                   // 1211,

922,                    // 1009,

790,                    // 865,

691,                    // 757,

552,                    // 757,

460,                    // 757,

394,                    // 757,

};



// I just took the following table from FM TOWNS Technical Databook,

// but I have no idea what's the hell this table is for.

static unsigned int attackTime10to90Percent[64]=

{

0,

0,

0,

0,

0,

468891,

333005,

333005,

249446,

200294,

166502,

141926,

124723,

100147,

83251,

70963,



62362,

50074,

41625,

35482,

31181,

25037,

20813,

17741,

15590,

12518,

10406,

8670,

7795,

6259,

5203,

4435,



3899,

3130,

2602,

2218,

1949,

1565,

1301,

1109,

974,

782,

650,

554,

497,

391,

325,

277,



241,

194,

165,

140,

125,

99,

92,

70,

61,

46,

37,

32,

26,

26,

0,

0,

};

static unsigned int sustainDecayReleaseTime10to90Percent[64]=

{

0,

0,

0,

0,

0,

2491484, // 5:

1658880, // 6:

1658880, // 7:

1247232, // 8: 2491484/2

998400,  // 9: 1996800/2

823440,  //10: 

712704,  //11:

623616,  //12: 2491484/4

498200,  //13: 1996800/4  499200?

414720,  //14: 

356352,  //15: 



311808,  //16: 2491484/8

249600,

207360,

178175,

155904,

124800,

103680,

89088,

77952,

62400,

51840,

44544,

38876,

31200,

25920,

22272,



19488,

15800,

12960,

11136,

9744,

7800,

6480,

5568,

4872,

3900,

3240,

2784,

2436,

1950,

1620,

1392,



1218,

975,

810,

696,

509,

480,

407,

350,

305,

243,

203,

173,

152,

152,

152,

152,

};



const struct YM2612::ConnectionToOutputSlot YM2612::connectionToOutputSlots[8]=

{

	{1,{3,-1,-1,-1}},

	{1,{3,-1,-1,-1}},

	{1,{3,-1,-1,-1}},

	{1,{3,-1,-1,-1}},

	{2,{1,3,-1,-1}},

	{3,{1,2,3,-1}},

	{3,{1,2,3,-1}},

	{4,{0,1,2,3}},

};



static unsigned int detune1000Table[]=

{

	   0,   0,  48,  95,

	   0,   0,  48,  95,

	   0,   0,  48,  95,

	   0,   0,  48,  95,

	   0,  48,  95,  95,

	   0,  48,  95, 143,

	   0,  48,  95, 143,

	   0,  48,  95, 143,

	   0,  48,  95, 191,

	   0,  48, 143, 191,



	   0,  48, 143, 191,

	   0,  48, 143, 238,

	   0,  95, 191, 238,

	   0,  95, 191, 286,

	   0,  95, 191, 288,

	   0,  95, 238, 334,

	   0,  85, 238, 381, // 85?

	   0, 143, 286, 381,

	   0, 143, 298, 429,

	   0, 143, 334, 477,



	   0, 191, 381, 525,

	   0, 191, 381, 572,

	   0, 191, 429, 620,

	   0, 238, 477, 668,

	   0, 238, 525, 763,

	   0, 286, 672, 811,

	   0, 286, 520, 906,

	   0, 334, 668, 354,

	   0, 391, 763,1049,

	   0, 391, 763,1049,



	   0, 391, 763,1049,

	   0, 391, 763,1049,

};



////////////////////////////////////////////////////////////



/*static*/ unsigned int YM2612::attackExp[4096];         // 0 to 4095 scale in -> 0 to 4095 scale out.

/*static*/ unsigned int YM2612::attackExpInverse[4096];  // 0 to 4095 scale in -> 0 to 4095 scale out.



////////////////////////////////////////////////////////////







static unsigned int LFOCycleMicroSec[8]=

{

	100000000/ 398, // 1000000/ 3.98,

	100000000/ 556, // 1000000/ 5.56,

	100000000/ 602, // 1000000/ 6.02,

	100000000/ 637, // 1000000/ 6.37,

	100000000/ 688, // 1000000/ 6.88,

	100000000/ 963, // 1000000/ 9.63,

	100000000/4810, // 1000000/48.10,

	100000000/7220  // 1000000/72.20

};



// Definition of cent.

// https://ja.wikipedia.org/wiki/%E3%82%BB%E3%83%B3%E3%83%88_(%E9%9F%B3%E6%A5%BD)

static int PMS16384Table[8]=

{

  0,

 32,// scale(3.400000)=1.001966, (1.001966-1.0)*16384.0=32

 63,// scale(6.700000)=1.003878, (1.003878-1.0)*16384.0=63

 94,// scale(10.000000)=1.005793, (1.005793-1.0)*16384.0=94

133,// scale(14.000000)=1.008120, (1.008120-1.0)*16384.0=133

190,// scale(20.000000)=1.011619, (1.011619-1.0)*16384.0=190

382,// scale(40.000000)=1.023374, (1.023374-1.0)*16384.0=382

774,// scale(80.000000)=1.047294, (1.047294-1.0)*16384.0=774

};



// dB=20log10(P/Pref)

// 0=20log10(P/Pref) -> P/Pref=1.0

// 1.4=20log10(P/Pref) -> 10^(1.4/20)=P/Pref -> 

// 5.9=20log10(P/Pref) -> 10^(5.9/20)=P/Pref ->

// 11.8=20log10(P/Pref) -> 10^(11.8/20)=P/Pref ->

static int AMS4096Table[4]=

{

 4096-4096,  // 1.0

 4812-4096,  // 1.1749

 8079-4096,  // 1.97242

15935-4096, // 3.89045

};



////////////////////////////////////////////////////////////



int YM2612::Slot::DetuneContributionToPhaseStepS12(unsigned int BLOCK,unsigned int NOTE) const

{

	// Hz ranges 1 to roughly 8000.  PHASE_STEPS=4096.  hertz*PHASE_STEPS=2^13*2^12=2^25. Fits in 32 bit.

	long long int detuneStepContribution=0;

	if(0!=DT)

	{

		long long int hertz1000=detune1000Table[(BLOCK<<4)+(NOTE<<2)+(DT&3)];

		detuneStepContribution=(hertz1000*PHASE_STEPS);

		detuneStepContribution<<=12;

		detuneStepContribution/=1000;  // Now it is (hertz*PHASE_STEPS)<<12.

		if(0!=(DT&4))

		{

			detuneStepContribution=-detuneStepContribution;

		}

	}

	return (int)detuneStepContribution;

}



inline int YM2612::Slot::UnscaledOutput(int phase,int phaseShift) const

{

	// phaseShift is input from the upstream slot.

	// -4096 to 4096.  4096 should be counted as 8pi.

	// UNSCALED_MAX is 2048. therefore 8x.



	//phaseShift*=MULTITable[this->MULTI];

	//phaseShift>>=1;



	//                     8.0       * (2PI / 2)     /   1.0

	const int outputScale=SLOTOUT_TO_NPI*(PHASE_STEPS/2)/UNSCALED_MAX;

	return sineTable[(phase+(phaseShift*outputScale))&PHASE_MASK];

}

inline int YM2612::Slot::UnscaledOutput(int phase,int phaseShift,unsigned int FB,int lastSlot0Out) const

{

	if(0!=FB)

	{

		static const int FBScaleTable[]=

		{

			0,1,2,4,8,16,32,64

		};

		// lastSlotOut=1.0=>UNSCALED_MAX   4096=>2PI

		// To make it 4PI(8192) at FB=7(scale=64), must divide by UNSCALED_MAX*64/8192.

		// What was I thinking when I made div=32?  It should be 16.

		const int div=UNSCALED_MAX*64/8192;

		phase+=(lastSlot0Out*FBScaleTable[FB]/div);

	}

	//                     8.0       * (2PI / 2)     /   1.0

	const int outputScale=SLOTOUT_TO_NPI*(PHASE_STEPS/2)/UNSCALED_MAX;

	return sineTable[(phase+(phaseShift*outputScale))&PHASE_MASK];

}

inline int YM2612::Slot::EnvelopedOutputDbToAmpl(int phase,int phaseShift,unsigned int timeInMS,unsigned int FB,int lastSlot0Out) const

{

	int dB=InterpolateEnvelope(timeInMS);

	lastDbX100Cache=dB;

	int ampl=DB100to4095Scale[dB];

	int unscaledOut=UnscaledOutput(phase,phaseShift,FB,lastSlot0Out);

	return (unscaledOut*ampl)/4096;

}

inline int YM2612::Slot::EnvelopedOutputDbToAmpl(int phase,int phaseShift,unsigned int timeInMS) const

{

	int dB=InterpolateEnvelope(timeInMS);

	lastDbX100Cache=dB;

	int ampl=DB100to4095Scale[dB];

	int unscaledOut=UnscaledOutput(phase,phaseShift);

	return (unscaledOut*ampl)/4096;

}

inline int YM2612::Slot::InterpolateEnvelope(unsigned int timeInMS) const

{

	if(true!=InReleasePhase)

	{

		if(timeInMS<env[0]) // Attack

		{

			unsigned int x=4096*timeInMS/env[0];

			return (env[1]*attackExp[x])>>12;

		}

		else

		{

			timeInMS-=env[0];

			if(timeInMS<env[2])

			{

				return env[1]-(env[1]-env[3])*timeInMS/env[2];

			}

			else

			{

				timeInMS-=env[2];

				if(timeInMS<env[4])

				{

					return env[3]-env[3]*timeInMS/env[4];

				}

			}

		}

		return 0;

	}

	else

	{

		if(timeInMS<ReleaseEndTime && ReleaseStartTime<ReleaseEndTime)

		{

			auto diff=ReleaseEndTime-timeInMS;

			auto DbX100=ReleaseStartDbX100;

			DbX100*=diff;

			DbX100/=(ReleaseEndTime-ReleaseStartTime);

			return DbX100;

		}

		return 0; // Not supported yet.

	}

}



unsigned int YM2612::Channel::Note(void) const

{

	// Formula [2] pp.204

	// There is an error.  F_NUM is 11bits.  There is no F11.

	// Probably, F11, F10, F9, F8 should be read bit10, bit9, bit8, bit7.

	unsigned int F10=((F_NUM>>10)&1);

	unsigned int F9= ((F_NUM>> 9)&1);

	unsigned int F8= ((F_NUM>> 8)&1);

	unsigned int F7=((F_NUM>>11)&1);

	unsigned int N3=(F10&(F9|F8|F7)); // |((~F10)&F9&F8&F7);  Measurement from actual FM TOWNS 2MX suggests no contribution from the second term.

	unsigned int NOTE=(F10<<1)|N3;

	return NOTE;

}



unsigned int YM2612::Channel::KC(void) const

{

	// Formulat in [2] pp.204 suggests:

 	//   unsigned int KC=(ch.BLOCK<<2)|NOTE;

	// which doesn't make sense.

	// SEGA Genesis Software Manaual tells KC is just top 5 bits of BLOCK|F_NUM2.

	// Which makes more sense.



	// Measurement taken from FM TOWNS 2MX gave a conclusion:

	//   NOTE=(N4<<1)|N3

	//   N4=F11

	//   N3=F11&(F10|F9|F8)

	// F11 Highest bit of F_NUMBER

	// F10 Second highest bit of F_NUMBER

	// F9  Third highest bit of F_NUMBER

	// F8  Fourth highest bit of F_NUMBER



	// YAMAHA official manual for YM2608 Section 2-4-1-A, and FM Towns Technical Databook suggests:

	//    N3=(F11&(F10|F9|F8))|((~F11)&F10&F9&F8)

	// However, the actual YM2612 didn't show any contribution from ((~F11)&F10&F9&F8).



	unsigned int N4=((F_NUM>>9)&2);

	unsigned int N3=((F_NUM>>10)&((F_NUM>>9)|(F_NUM>>8)|(F_NUM>>7)))&1;

	unsigned int KC=(BLOCK<<2)|N4|N3;

	return KC&0x1F;

}



////////////////////////////////////////////////////////////



void YM2612::KeyOn(unsigned int chNum,unsigned int slotFlags)

{

	if(0==slotFlags)

	{

		return;

	}





	auto &ch=state.channels[chNum];



	const unsigned int hertzX16=BLOCK_FNUM_to_FreqX16(ch.BLOCK,ch.F_NUM);



	state.playingCh|=(1<<chNum);

	ch.playState=CH_PLAYING;

	if(0!=(1&slotFlags))

	{

		ch.lastSlot0Out[0]=0;

		ch.lastSlot0Out[1]=0;

	}



	for(int i=0; i<NUM_SLOTS; ++i)

	{

		if(0!=(slotFlags&(1<<i)))

		{

			auto &slot=ch.slots[i];



			slot.InReleasePhase=false;

			slot.phaseS12=0;



			UpdatePhase12StepSlot(slot,hertzX16,slot.DetuneContributionToPhaseStepS12(ch.BLOCK,ch.Note()));



			// (hertzX16*PHASE_STEPS)<<8==hertz*PHASE_STEPS*4096

			UpdateSlotEnvelope(ch,slot);



			// Observation tells that if key is turned on while the previous tone is still playing, 

			// The initial output level must start from the last output level, in which case

			// microsec12 must fast-forwarded so that the output matches the lastDbX100Cache.

			// Linear interpolation will have error, but should be better than nothing.

			if(slot.lastDbX100Cache<=0)

			{

				slot.microsecS12=0;

			}

			else if(slot.env[1]<=slot.lastDbX100Cache)

			{

				slot.microsecS12=(slot.env[0]<<(12+10));

			}

			else

			{

				unsigned int scale=attackExpInverse[4096*slot.lastDbX100Cache/slot.env[1]];

				slot.microsecS12=(slot.env[0]*scale/4096)<<(12+10);

			}

			slot.lastDbX100Cache=0;

		}

	}



#ifdef YM2612_DEBUGOUTPUT

	printf("%d BLOCK %03xH F_NUM %03xH Hertz %d\n",KC,ch.BLOCK,ch.F_NUM,hertzX16/16);

#endif

}



void YM2612::UpdatePhase12StepSlot(Slot &slot,const unsigned int hertzX16,int detuneContribution)

{

	// Phase runs hertz*PHASE_STEPS times per second.

	//            hertz*PHASE_STEPS/WAVE_SAMPLING_RATE times per step.

	// Phase 12 runs

	//            0x1000*hertz*PHASE_STEPS/WAVE_SAMPLING_RATE per step.

	unsigned long long phaseS12Step;

	phaseS12Step=MULTITable[slot.MULTI]*hertzX16*PHASE_STEPS; // 2X from MULTITable, 16X from hertzX16

	phaseS12Step<<=7;                                         // 128X  Overall 2x16x128=4096X

	phaseS12Step+=MULTITable[slot.MULTI]*detuneContribution/2;

	phaseS12Step/=WAVE_SAMPLING_RATE;

	slot.phaseS12Step=(unsigned int)phaseS12Step;

}



void YM2612::UpdatePhase12StepSlot(Channel &ch)

{

	const unsigned int hertzX16=BLOCK_FNUM_to_FreqX16(ch.BLOCK,ch.F_NUM);

	for(auto &slot : ch.slots)

	{

		UpdatePhase12StepSlot(slot,hertzX16,slot.DetuneContributionToPhaseStepS12(ch.BLOCK,ch.Note()));

	};

}



void YM2612::KeyOff(unsigned int chNum,unsigned int slotFlags)

{

	if(0!=(state.playingCh&(1<<chNum)))

	{

		auto &ch=state.channels[chNum];

		for(auto &slot : ch.slots)

		{

			if(true!=slot.InReleasePhase)

			{

				slot.InReleasePhase=true;

				UpdateRelease(ch,slot);

			}

		}

	}

}



void YM2612::CheckToneDone(unsigned int chNum)

{

	auto &ch=state.channels[chNum];

	if(CH_PLAYING!=ch.playState)

	{

		state.playingCh&=~(1<<chNum);

	}

	else

	{

		bool slotStillPlaying=false;

		for(int i=0; i<connectionToOutputSlots[ch.CONNECT].nOutputSlots; ++i)

		{

			auto &slot=ch.slots[connectionToOutputSlots[ch.CONNECT].slots[i]];

			auto millisec=(slot.microsecS12>>(10+12));

			if(true==slot.InReleasePhase && millisec<slot.ReleaseEndTime)

			{

				slotStillPlaying=true;

				break;;

			}

			else if(true!=slot.InReleasePhase && millisec<slot.envDurationCache)

			{

				slotStillPlaying=true;

				break;;

			}

		}

		if(true!=slotStillPlaying)

		{

			state.playingCh&=~(1<<chNum);

			ch.playState=CH_IDLE;

			for(auto &s : ch.slots)

			{

				s.lastDbX100Cache=0;

				s.InReleasePhase=false;

			}

		}

	}

}



void YM2612::CheckToneDoneAllChannels(void)

{

	for(unsigned int chNum=0; chNum<NUM_CHANNELS; ++chNum)

	{

		CheckToneDone(chNum);

	}

}



std::vector <unsigned char> YM2612::MakeWaveAllChannels(unsigned long long int millisec) const

{

	std::vector <unsigned char> wave;



	unsigned long long int numSamples=(millisec<<12);

	numSamples*=WAVE_SAMPLING_RATE;

	numSamples/=1000;

	numSamples>>=12;



	wave.resize(4*numSamples);



	unsigned int nPlayingCh=0;

	unsigned int playingCh[NUM_CHANNELS];

	for(unsigned int chNum=0; chNum<NUM_CHANNELS; ++chNum)

	{

		if(0!=(state.playingCh&(1<<chNum)))

		{

			playingCh[nPlayingCh++]=chNum;

		}

	}

	MakeWaveForNSamples(wave.data(),nPlayingCh,playingCh,numSamples);

	return wave;

}



std::vector <unsigned char> YM2612::MakeWave(unsigned int ch,unsigned long long int millisec) const

{

	std::vector <unsigned char> wave;



	unsigned long long int numSamples=(millisec<<12);

	numSamples*=WAVE_SAMPLING_RATE;

	numSamples/=1000;

	numSamples>>=12;



	wave.resize(4*numSamples);



	unsigned int playingCh[1]={ch};

	MakeWaveForNSamples(wave.data(),1,playingCh,numSamples);

	return wave;

}



class YM2612::WithLFO

{

public:

	static inline void CalculateLFO(int AMSAdjustment[4],int PMSAdjustment[4],unsigned int FREQCTRL,const Channel &ch)

	{

		if(0!=ch.PMS)

		{

			for(unsigned int i=0; i<connectionToOutputSlots[ch.CONNECT].nOutputSlots; ++i)

			{

				auto sl=connectionToOutputSlots[ch.CONNECT].slots[i];

				int signedStep=ch.slots[sl].phaseS12Step;



				unsigned long long int LFOPhase=(ch.slots[sl].microsecS12>>12);

				LFOPhase=LFOPhase*PHASE_STEPS/LFOCycleMicroSec[FREQCTRL];



				int PMSAdj=PMS16384Table[ch.PMS]*sineTable[LFOPhase&PHASE_MASK]/UNSCALED_MAX;

				PMSAdjustment[sl]=signedStep*PMSAdj/16384/2;

			}

		}

		{

			for(unsigned int i=0; i<connectionToOutputSlots[ch.CONNECT].nOutputSlots; ++i)

			{

				auto sl=connectionToOutputSlots[ch.CONNECT].slots[i];

				if(0!=ch.slots[sl].AM)

				{

					unsigned long long int LFOPhase=(ch.slots[sl].microsecS12>>12);

					LFOPhase=LFOPhase*PHASE_STEPS/LFOCycleMicroSec[FREQCTRL];

					AMSAdjustment[sl]=4096+(AMS4096Table[ch.AMS]*sineTable[LFOPhase&PHASE_MASK])/UNSCALED_MAX;

				}

			}

		}

	}

	static inline const int AMSMul(const int AMS)

	{

		return AMS;

	}

	static inline constexpr int AMSDiv(void)

	{

		return 4096;

	}

};



class YM2612::WithoutLFO

{

public:

	static inline void CalculateLFO(int AMSAdjustment[4],int PMSAdjustment[4],unsigned int FREQCTRL,const Channel &ch)

	{

	}

	static inline constexpr int AMSMul(const int)

	{

		return 1;

	}

	static inline constexpr int AMSDiv(void)

	{

		return 1;

	}

};



template <class LFOClass>

long long int YM2612::MakeWaveForNSamplesTemplate(unsigned char wave[],unsigned int nPlayingCh,unsigned int playingCh[],unsigned long long int numSamples) const

{

	const unsigned int microsecS12Step=4096000000/WAVE_SAMPLING_RATE;

	// Time runs 1/WAVE_SAMPLING_RATE seconds per step

	//           1000/WAVE_SAMPLING_RATE milliseconds per step

	//           1000000/WAVE_SAMPLING_RATE microseconds per step

	//           1000000000/WAVE_SAMPLING_RATE nanoseconds per step



	// If microSec12=4096*microseconds, tm runs

	//           4096000000/WAVE_SAMPLING_RATE per step



	unsigned int LeftANDPtn[NUM_CHANNELS];

	unsigned int RightANDPtn[NUM_CHANNELS];



	for(unsigned int chNum=0; chNum<NUM_CHANNELS; ++chNum)

	{

		auto &ch=state.channels[chNum];

		LeftANDPtn[chNum]=(0!=ch.L ? ~0 : 0);

		RightANDPtn[chNum]=(0!=ch.R ? ~0 : 0);

	}



	unsigned int i;

	for(i=0; i<numSamples && 0<nPlayingCh; ++i)

	{

		int leftOut=0,rightOut=0;

		for(int j=nPlayingCh-1; 0<=j; --j)

		{

			auto chNum=playingCh[j];

			auto &ch=state.channels[chNum];

			if(ch.slots[0].toneDurationMicrosecS12<=ch.slots[0].microsecS12 &&

			   ch.slots[1].toneDurationMicrosecS12<=ch.slots[1].microsecS12 &&

			   ch.slots[2].toneDurationMicrosecS12<=ch.slots[2].microsecS12 &&

			   ch.slots[3].toneDurationMicrosecS12<=ch.slots[3].microsecS12)

			{

				playingCh[j]=playingCh[nPlayingCh-1];

				--nPlayingCh;

				break;

			}



			int PMSAdjustment[4]=

			{

				0,0,0,0

			};

			int AMSAdjustment[4]=

			{

				4096,4096,4096,4096

			};



			LFOClass::CalculateLFO(AMSAdjustment,PMSAdjustment,state.FREQCTRL,ch);





			// Why take an average of last two samples, not just the last sample, for feedback?

			// Cisc's FMGEN YM emulator does it.  I was wondering why.  But, it works as a damper to prevent

			// premature divergence.

			// 

			// When feedback is given, the output from slot 0 is calculated as:

			// 

			//     y(i+1)=A*sin(i*dt+C*y(i))

			// 

			// A is amplitude calculated from the envelope, and C is defined by feedback level, and

			// dt depends on the frequency of the tone.

			// 

			// Let's denote the angle given to the sine function as:

			// 

			//     X(i)=i*dt+C*y(i)

			// 

			// When the slope of sin(X(i)) is negative (0.5PI<X(i)<1.5PI), means the value is decreasing with

			// increasing X, the function can become unstable and diverge, until the function returns to the

			// positive slope.  Here's what can happen.

			// 

			// X(i) monotonicly increase if C=0, means no feedback.  However, if C is non-zero, i*dt increases, 

			// but C*y(i) can increase or decrease depending on the slope of y(i).

			// 

			// If the one-step decrease of C*y(i) exceeds the increase of i*dt (which is dt), 

			// X(i) will decrease overall, which means the input to the sine functions goes backward.

			// Amplitude is positive, and if the slope of the sine function at X(i) was negative, and if 

			// the input goes backward, y suddenly increases. i.e., y(i+1) is greater than y(i).

			// 

			// Then in the next step, both C*y and i*dt terms increase.  This makes a large jump of X.

			// The sine function is going down with X, as a result y dives down bigger than the last 

			// increase.  Then, the next comes even bigger increase of y, followed by even bigger dive, 

			// and the function of y(i) starts oscillating every sample.

			// 

			// From the above, the condition that starts this divergence is:

			// 

			//     dt<-dY

			// 

			// where Y=C*y(i).  Interestingly, because of this condition, this particular mode of oscillation

			// only appears when dY<0.

			// 

			// While it is a legitimate divergence that adds some noise component to the tone in some settings,

			// Slot 0 starts this oscillation too easily.

			// 

			// Cisc's FMGEN YM-chip emulator, used in XM7 and M88 emulators (and maybe other emulators as well)

			// solves this problem by feeding the average of the last two samples back to slot 0.

			// 

			// During the oscillation, the value of y jumps up and down.  But, if you look at the middle of the two

			// consecutive outputs, it goes through a smooth decreasing curve.

			// 

			// The cause of this divergence is from the oscillation of the feedback term, C*y.  By taking average

			// of the last two samples, it essentially damps the oscillation, and effectively prevents this divergence.

			//

			// So the modified formulation is:

			//

			//     y(i+1)=A*sin(i*dt+C*(y(i)+y(i-1))/2)

			//

			// Here I am explicitly writing it out, but Cisc's implementation embedded this division by two

			// in the anyway-required bit shift.

			//

			// Very genious solution it is.



			auto s0Out=(ch.lastSlot0Out[1]+ch.lastSlot0Out[0])/2;

			const uint64_t microsecS12[4]=

			{

				ch.slots[0].microsecS12,

				ch.slots[1].microsecS12,

				ch.slots[2].microsecS12,

				ch.slots[3].microsecS12,

			};

			const unsigned int phaseS12[4]=

			{

				ch.slots[0].phaseS12,

				ch.slots[1].phaseS12,

				ch.slots[2].phaseS12,

				ch.slots[3].phaseS12,

			};

			auto ampl=CalculateAmplitude<LFOClass>(chNum,microsecS12,phaseS12,AMSAdjustment,s0Out);

			ch.lastSlot0Out[1]=ch.lastSlot0Out[0];

			ch.lastSlot0Out[0]=s0Out;



			leftOut+=(LeftANDPtn[chNum]&ampl);

			rightOut+=(RightANDPtn[chNum]&ampl);



			ch.slots[0].phaseS12+=ch.slots[0].phaseS12Step+PMSAdjustment[0];

			ch.slots[1].phaseS12+=ch.slots[1].phaseS12Step+PMSAdjustment[1];

			ch.slots[2].phaseS12+=ch.slots[2].phaseS12Step+PMSAdjustment[2];

			ch.slots[3].phaseS12+=ch.slots[3].phaseS12Step+PMSAdjustment[3];

			ch.slots[0].microsecS12+=microsecS12Step;

			ch.slots[1].microsecS12+=microsecS12Step;

			ch.slots[2].microsecS12+=microsecS12Step;

			ch.slots[3].microsecS12+=microsecS12Step;

		}

		WordOp_Set(wave+i*4  ,leftOut);

		WordOp_Set(wave+i*4+2,rightOut);

	}



	std::memset(wave+i*4,0,(numSamples-i)*4);



// std::cout << (microsec12>>12) << "us " << std::endl;

// std::cout << phase12[0] << "," << (phase12[0]>>12)/PHASE_STEPS << "cycles" << std::endl;

// std::cout << phase12[1] << "," << (phase12[1]>>12)/PHASE_STEPS << "cycles" << std::endl;

// std::cout << phase12[2] << "," << (phase12[2]>>12)/PHASE_STEPS << "cycles" << std::endl;

// std::cout << phase12[3] << "," << (phase12[3]>>12)/PHASE_STEPS << "cycles" << std::endl;



	return i;

}



long long int YM2612::MakeWaveForNSamples(unsigned char wavBuf[],unsigned long long int numSamplesRequested) const

{

	unsigned int nPlayingCh=0;

	unsigned int playingCh[NUM_CHANNELS];

	for(unsigned int chNum=0; chNum<NUM_CHANNELS; ++chNum)

	{

		if(0!=(state.playingCh&(1<<chNum)))

		{

			playingCh[nPlayingCh++]=chNum;

		}

	}

	return MakeWaveForNSamples(wavBuf,nPlayingCh,playingCh,numSamplesRequested);

}



long long int YM2612::MakeWaveForNSamples(unsigned char wave[],unsigned int nPlayingCh,unsigned int playingCh[],unsigned long long int numSamples) const

{

	if(true==state.LFO)

	{

		return MakeWaveForNSamplesTemplate <WithLFO> (wave,nPlayingCh,playingCh,numSamples);

	}

	else

	{

		return MakeWaveForNSamplesTemplate <WithoutLFO> (wave,nPlayingCh,playingCh,numSamples);

	}

}



void YM2612::UpdateSlotEnvelope(const Channel &ch,Slot &slot)

{

	CalculateEnvelope(slot.env,ch.KC(),slot);

	slot.envDurationCache=slot.env[0]+slot.env[2]+slot.env[4];

	slot.toneDurationMicrosecS12=slot.envDurationCache;  // In Microsec/1024

	slot.toneDurationMicrosecS12<<=(12+10);

}



void YM2612::UpdateRelease(const Channel &ch,Slot &slot)

{

	auto KC=ch.KC();

	auto RR=(slot.RR*2+1)*2+(KC>>(3-slot.KS));  // [2] pp.206 Double RR and add 1.



	// 2020/12/15 nextMicrosecS12 retains up to what time point wave has been generated.

	//            Therefore, here must be nextMicrosecS12, instead of microsecS12.

	//            If microsecS12 is used, it virtually skips first 20ms of release,

	//            and the amplitude drops like a stairstep.

	//            It is inaudible in many situations, but clearly audible in Super Daisenryaku opening.

	// 2020/12/23 Got rid of nextMicrosecS12.

	slot.ReleaseStartTime=(slot.microsecS12>>(12+10));

	slot.ReleaseStartDbX100=slot.lastDbX100Cache;



	// Strike Commander set TL to 126, and then key off after landing and full stop.

	// Since no wave is calculated between TL=126 and key off, 

	// it creates a situation in which last output level is greater than the peak output level.

	// Therefore in such a situation, ReleaseStartDbX100 should be made at least less than TL.

	if(slot.env[1]<slot.ReleaseStartDbX100)

	{

		slot.ReleaseStartDbX100=slot.env[1];

	}





	uint64_t releaseTime=sustainDecayReleaseTime0to96dB[std::min<unsigned int>(RR,63)];

	releaseTime*=slot.lastDbX100Cache;

	releaseTime/=(9600*1024/10);

	slot.ReleaseEndTime=slot.ReleaseStartTime+releaseTime;

#ifdef YM2612_DEBUGOUTPUT

	std::cout << "Release Time " << releaseTime << "ms  " << 

	             "Start " << slot.ReleaseStartTime << "ms  " << 

	             "End " << slot.ReleaseEndTime << "ms" << std::endl;

#endif

}



bool YM2612::CalculateEnvelope(unsigned int env[6],unsigned int KC,const Slot &slot) const

{

#ifdef YM2612_DEBUGOUTPUT

	std::cout << KC << "," << slot.KS << "," << (KC>>(3-slot.KS)) << ", ";

#endif



	unsigned int AR=slot.AR*2+(KC>>(3-slot.KS));

	unsigned int DR=slot.DR*2+(KC>>(3-slot.KS));

	unsigned int SR=slot.SR*2+(KC>>(3-slot.KS));

	AR=std::min(AR,63U);

	DR=std::min(DR,63U);

	SR=std::min(SR,63U);



	if(AR<4)

	{

		return NoTone(env);

	}



	auto TLdB100=TLtoDB100[slot.TL];

	auto SLdB100=SLtoDB100[slot.SL];



	if(9600<=TLdB100)

	{

		return NoTone(env);

	}



	const unsigned int TLinv=9600-TLdB100;



#ifdef YM2612_DEBUGOUTPUT

	std::cout << "AR=" << AR << " DR=" << DR << " SR=" << SR << " TL=" << slot.TL  << " SL=" << slot.SL ;

	std::cout << " ";

#endif



	// Ealier I was linearly interpolating the amplitude, but maybe it is linear in dB scale.

	env[1]=TLinv;

	env[3]=(SLdB100<TLinv ? TLinv-SLdB100 : 0);

	env[5]=0;





	// After reading fmgen.c (Written by cisc, Author of M88 PC8801 emulator), it looks to be that

	// the time for attack doesn't depend on the total level, but it takes time to raise 0dB to 96dB all the time.

	// Then, the time for decay is based on SL only.  Just like dropping from 96dB to 96-dB(SL) dB.

	// The secondary decay duration should also depend only on SL, the time for 96-dB(SL)dB to 0dB.

	// The amplitude change is not linear, but I approximate by a linear function.  I may come back to the envelope

	// generation once I get a good enough approximation.

	unsigned long long int mul;

	env[0]=(attackTime0to96dB[AR]*10)>>10;  // *10 to make it microsed, and then divide by 1024.

	mul=SLdB100;

	mul*=sustainDecayReleaseTime0to96dB[DR];

	mul/=(9600*1024/10);

	env[2]=(unsigned int)mul;

	mul=9600-SLdB100;

	mul*=sustainDecayReleaseTime0to96dB[SR];

	mul/=(9600*1024/10);

	env[4]=(unsigned int)mul;



	// ?

	// If, AR, DR, SR, and RR are really rates, the duration for attack, decay, and sustain should depend

	// on the amplitude.  If the amplitude for total level is high, it should take longer to get to the level.

	// Or, if it is the rate, the slope of the decay should be the same regardless of the TL amplitude.

	// But, the value calculated from this assumption doesn't make sense at all.

	// It rather makes sense if I take the number from the table without scaling by the amplitude.



	// env[0]=attackTime0to96dB[AR]/100;

	// env[2]=sustainDecayReleaseTime0to96dB[DR]/100;

	// env[4]=sustainDecayReleaseTime0to96dB[SR]/100;



	// ?

	// If it is really rate, the following code should better emulate, but doesn't look to be.

	// unsigned long long int attackTime=attackTime0to96dB[AR]; // 1/100 milliseconds for jumping from 0 to 127 (96dB)

	// // If TLampl==127, it takes attackTime/100 milliseconds to reach TLampl.

	// attackTime*=TLampl;

	// env[0]=(unsigned int)(attackTime/12700);



	// unsigned long long int decayTime=sustainDecayReleaseTime0to96dB[DR];

	// decayTime*=(TLampl-SLampl);

	// env[2]=(unsigned int)(decayTime/12700);



	// unsigned long long int sustainTime=sustainDecayReleaseTime0to96dB[SR];

	// sustainTime*=SLampl;

	// sustainTime/=127;

	// if(sustainTime<TONE_CHOPOFF_MILLISEC*100)

	// {

	// 	env[4]=(unsigned int)(sustainTime/12700);

	// }

	// else

	// {

	// 	env[4]=TONE_CHOPOFF_MILLISEC;

	// }



#ifdef YM2612_DEBUGOUTPUT

	for(int i=0; i<6; ++i){std::cout << env[i] << ",";}

	std::cout << std::endl;

#endif



	return true;

}



template <class LFOClass>

int YM2612::CalculateAmplitude(int chNum,const uint64_t timeInMicrosecS12[NUM_SLOTS],const unsigned int slotPhaseS12[NUM_SLOTS],const int AMS4096[4],int &lastSlot0Out) const

{

	if(true==channelMute[chNum])

	{

		return 0;

	}



	auto &ch=state.channels[chNum];

	bool slotActive[4]=

	{

		0!=(ch.usingSlot&1) || ch.slots[0].InReleasePhase,

		0!=(ch.usingSlot&2) || ch.slots[1].InReleasePhase,

		0!=(ch.usingSlot&4) || ch.slots[2].InReleasePhase,

		0!=(ch.usingSlot&8) || ch.slots[3].InReleasePhase,

	};



	unsigned int timeInMS[NUM_SLOTS]=

	{

		(unsigned int)(timeInMicrosecS12[0]>>(12+10)),

		(unsigned int)(timeInMicrosecS12[1]>>(12+10)),

		(unsigned int)(timeInMicrosecS12[2]>>(12+10)),

		(unsigned int)(timeInMicrosecS12[3]>>(12+10)),

	};



	#define SLOTOUTEV_Db_0(phaseShift) ((true!=slotActive[0] ? 0 : ch.slots[0].EnvelopedOutputDbToAmpl((slotPhaseS12[0]>>12),phaseShift,timeInMS[0],ch.FB,lastSlot0Out))*LFOClass::AMSMul(AMS4096[0])/LFOClass::AMSDiv())

	#define SLOTOUTEV_Db_1(phaseShift) ((true!=slotActive[1] ? 0 : ch.slots[1].EnvelopedOutputDbToAmpl((slotPhaseS12[1]>>12),phaseShift,timeInMS[1]))*LFOClass::AMSMul(AMS4096[1])/LFOClass::AMSDiv())

	#define SLOTOUTEV_Db_2(phaseShift) ((true!=slotActive[2] ? 0 : ch.slots[2].EnvelopedOutputDbToAmpl((slotPhaseS12[2]>>12),phaseShift,timeInMS[2]))*LFOClass::AMSMul(AMS4096[2])/LFOClass::AMSDiv())

	#define SLOTOUTEV_Db_3(phaseShift) ((true!=slotActive[3] ? 0 : ch.slots[3].EnvelopedOutputDbToAmpl((slotPhaseS12[3]>>12),phaseShift,timeInMS[3]))*LFOClass::AMSMul(AMS4096[3])/LFOClass::AMSDiv())



	int s0out,s1out,s2out,s3out;

	switch(ch.CONNECT)

	{

	default:

	case 0:

		s0out=SLOTOUTEV_Db_0(0);

		lastSlot0Out=s0out;

		s1out=SLOTOUTEV_Db_1(s0out);

		s2out=SLOTOUTEV_Db_2(s1out);

		return SLOTOUTEV_Db_3(s2out)*state.volume/UNSCALED_MAX;

	case 1:

		s0out=SLOTOUTEV_Db_0(0);

		lastSlot0Out=s0out;

		s1out=SLOTOUTEV_Db_1(0);

		s2out=SLOTOUTEV_Db_2(s0out+s1out);

		return SLOTOUTEV_Db_3(s2out)*state.volume/UNSCALED_MAX;

	case 2:

		s0out=SLOTOUTEV_Db_0(0);

		lastSlot0Out=s0out;

		s1out=SLOTOUTEV_Db_1(0);

		s2out=SLOTOUTEV_Db_2(s1out);

		return SLOTOUTEV_Db_3(s0out+s2out)*state.volume/UNSCALED_MAX;

	case 3:

		s0out=SLOTOUTEV_Db_0(0);

		lastSlot0Out=s0out;

		s1out=SLOTOUTEV_Db_1(s0out);

		s2out=SLOTOUTEV_Db_2(0);

		return SLOTOUTEV_Db_3(s1out+s2out)*state.volume/UNSCALED_MAX;

	case 4:

		s0out=SLOTOUTEV_Db_0(0);

		lastSlot0Out=s0out;

		s1out=SLOTOUTEV_Db_1(s0out);

		s2out=SLOTOUTEV_Db_2(0);

		s3out=SLOTOUTEV_Db_3(s2out);

		return ((s1out+s3out)*state.volume/UNSCALED_MAX);

		// Test only Slot 3 -> return SLOTOUTEV_Db_3(0)*state.volume/UNSCALED_MAX;

	case 5:

		s0out=SLOTOUTEV_Db_0(0);

		lastSlot0Out=s0out;

		s1out=SLOTOUTEV_Db_1(s0out);

		s2out=SLOTOUTEV_Db_2(s0out);

		s3out=SLOTOUTEV_Db_3(s0out);

		return ((s1out+s2out+s3out)*state.volume/UNSCALED_MAX);

	case 6:

		s0out=SLOTOUTEV_Db_0(0);

		lastSlot0Out=s0out;

		s1out=SLOTOUTEV_Db_1(s0out);

		s2out=SLOTOUTEV_Db_2(0    );

		s3out=SLOTOUTEV_Db_3(0    );

		return ((s1out+s2out+s3out)*state.volume/UNSCALED_MAX);

	case 7:

		s0out=SLOTOUTEV_Db_0(0);

		lastSlot0Out=s0out;

		s1out=SLOTOUTEV_Db_1(0);

		s2out=SLOTOUTEV_Db_2(0);

		s3out=SLOTOUTEV_Db_3(0);

		return ((s0out+s1out+s2out+s3out)*state.volume/UNSCALED_MAX);

	}

}

